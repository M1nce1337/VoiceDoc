<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>VoiceDoc — WebSocket ASR Prototype</title>
  <style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 20px; color:#0b1b2b; background:#f6f9fc; }
    h1 { font-size: 20px; margin-bottom: 8px; }
    .controls { margin-bottom: 12px; }
    button { padding: 8px 12px; margin-right:8px; border-radius:6px; border:1px solid #c7d6e6; background:white; cursor:pointer;}
    button.primary { background: #0b69ff; color: white; border-color:#0b69ff; }
    button.danger { background:#ff5c5c; color:white; border-color:#ff5c5c;}
    #status { display:inline-block; margin-left:8px; padding:4px 8px; border-radius:6px; background:#e6f0ff; color:#0b69ff; border:1px solid #c7d6e6;}
    #transcript, #structured { width: 100%; min-height: 120px; padding:10px; border-radius:8px; border:1px solid #d8e6f3; background:white; box-shadow:0 1px 2px rgba(11,25,40,0.04); }
    label { font-weight:600; display:block; margin-top:12px; margin-bottom:6px; }
    .row { display:flex; gap:8px; align-items:center; margin-top:8px; }
    .small { font-size:13px; color:#5a6b7b; }
  </style>
</head>
<body>
  <h1>VoiceDoc — WebSocket ASR (Prototype)</h1>

  <div class="controls">
    <button id="btnStart" class="primary">Начать запись</button>
    <button id="btnStop" class="danger" disabled>Остановить</button>
    <span id="status">Ожидание</span>
  </div>

  <label>Live транскрипция (partial / final):</label>
  <div id="transcript" contenteditable="false"></div>

  <div class="row">
    <button id="btnMakeStructured">Сформировать структуру (LLM)</button>
    <button id="btnCopy" style="display:inline-block">Копировать</button>
    <span class="small">→ Нажмите «Сформировать структуру» чтобы отправить текст в LLM (POST /llm/structure)</span>
  </div>

  <label>Структурированный результат (ответ LLM):</label>
  <pre id="structured"></pre>

  <script>


const WS_URL = "ws://localhost:8000/ws/audio"; 
const LLM_URL = "/llm/structure"; 

let ws = null;
let audioContext = null;
let processor = null;
let input = null;
let globalStream = null;

const btnStart = document.getElementById("btnStart");
const btnStop = document.getElementById("btnStop");
const statusEl = document.getElementById("status");
const transcriptEl = document.getElementById("transcript");
const structuredEl = document.getElementById("structured");
const btnMakeStructured = document.getElementById("btnMakeStructured");
const btnCopy = document.getElementById("btnCopy");

btnStart.onclick = startRecording;
btnStop.onclick = stopRecording;
btnMakeStructured.onclick = makeStructured;
btnCopy.onclick = copyStructured;

function setStatus(s) {
  statusEl.textContent = s;
}


function floatTo16BitPCM(float32Array) {
  const l = float32Array.length;
  const buffer = new ArrayBuffer(l * 2);
  const view = new DataView(buffer);
  let offset = 0;
  for (let i = 0; i < l; i++, offset += 2) {
    let s = Math.max(-1, Math.min(1, float32Array[i]));
    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
  }
  return buffer;
}


function arrayBufferToBase64(buffer) {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  const chunkSize = 0x8000;
  for (let i = 0; i < bytes.length; i += chunkSize) {
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
  }
  return btoa(binary);
}


function downsampleBuffer(buffer, sampleRate, outSampleRate = 16000) {
  if (outSampleRate === sampleRate) {
    return buffer;
  }
  const sampleRateRatio = sampleRate / outSampleRate;
  const newLength = Math.round(buffer.length / sampleRateRatio);
  const result = new Float32Array(newLength);
  let offsetResult = 0;
  let offsetBuffer = 0;
  while (offsetResult < result.length) {
    const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
    // average the range
    let accum = 0, count = 0;
    for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
      accum += buffer[i];
      count++;
    }
    result[offsetResult] = count ? (accum / count) : 0;
    offsetResult++;
    offsetBuffer = nextOffsetBuffer;
  }
  return result;
}


function initWebSocket() {
  if (ws && ws.readyState === WebSocket.OPEN) return;
  ws = new WebSocket(WS_URL);
  ws.binaryType = 'arraybuffer';

  ws.onopen = () => {
    transcriptEl.innerHTML = " ";
    setStatus("WS: подключено");
    console.log("WS connected");

    const hello = JSON.stringify({type: 'hello', role: 'client'});
    ws.send(hello);
  };
  ws.onmessage = (evt) => {
    let data = evt.data;
    if (typeof data === 'string') {
      try {
        const msg = JSON.parse(data);
        handleServerMessage(msg);
      } catch (e) {
        console.log("Received text:", data);
      }
    } else {
      console.log("Received binary message (ignored)");
    }
  };
  ws.onclose = () => {
    setStatus("WS: отключено");
    console.log("WS closed");
  };
  ws.onerror = (e) => {
    setStatus("WS: ошибка");
    console.error("WS error", e);
  };
}

function handleServerMessage(msg) {
  // ожидаем сообщения вида {type:'partial'|'final', text:'...', confidence:0.9}
  if (!msg.type) return;
  if (msg.type === 'partial') {
    // показываем как временный текст
    transcriptEl.textContent = (transcriptEl.dataset.confirmed || "") + " " + msg.text;
  } else if (msg.type === 'final') {
    // сохранить окончательный фрагмент
    const confirmed = transcriptEl.dataset.confirmed || "";
    const newConfirmed = (confirmed + " " + msg.text).trim();
    transcriptEl.dataset.confirmed = newConfirmed;
    transcriptEl.textContent = newConfirmed;
  } else if (msg.type === 'info') {
    // любые служебные сообщения
    setStatus("WS: " + (msg.msg || 'info'));
  } else if (msg.type === 'error') {
    setStatus("WS error: " + (msg.msg||''));
  } else {
    console.log("Unknown message", msg);
  }
}


async function startRecording() {
  btnStart.disabled = true;
  btnStop.disabled = false;
  initWebSocket();
  setStatus("Инициализация микрофона...");

  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    globalStream = stream;
    audioContext = new (globalThis.AudioContext || globalThis.webkitAudioContext)();
    const source = audioContext.createMediaStreamSource(stream);
    const bufferSize = 4096;
    processor = audioContext.createScriptProcessor(bufferSize, 1, 1);
    source.connect(processor);
    processor.connect(audioContext.destination);

    const inputSampleRate = audioContext.sampleRate;
    console.log("Input sampleRate:", inputSampleRate);

    processor.onaudioprocess = (e) => {
      const inputData = e.inputBuffer.getChannelData(0);
      const downsampled = downsampleBuffer(inputData, inputSampleRate, 16000);
      const pcm16Buffer = floatTo16BitPCM(downsampled);
      const b64 = arrayBufferToBase64(pcm16Buffer);
      if (ws && ws.readyState === WebSocket.OPEN) {
        const msg = JSON.stringify({ type: 'audio', encoding: 'pcm16', sample_rate: 16000, data: b64 });
        ws.send(msg);
      }
    };

    setStatus("Запись: отправка аудио в реальном времени");

  } catch (err) {
    console.error("getUserMedia error", err);
    setStatus("Ошибка доступа к микрофону");
    btnStart.disabled = false;
    btnStop.disabled = true;
  }
}


function stopRecording() {
  btnStart.disabled = false;
  btnStop.disabled = true;
  setStatus("Остановка...");
  if (processor) {
    processor.disconnect();
    processor.onaudioprocess = null;
    processor = null;
  }
  if (audioContext) {
    audioContext.close();
    audioContext = null;
  }
  if (globalStream) {
    for (const t of globalStream.getTracks()) t.stop();
    globalStream = null;
  }
 
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type: 'eof'}));
    setStatus("Ожидание результата...");
    ws.close()
    setStatus("Запись: отправка аудио в реальном времени");
  }
}


async function makeStructured() {
  const rawText = (transcriptEl.dataset.confirmed || "").trim();
  if (!rawText) {
    alert("Текст пустой — сперва продиктуйте что-нибудь.");
    return;
  }
  setStatus("Отправка в LLM...");
  structuredEl.textContent = "...";
  try {
    const resp = await fetch(LLM_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: rawText })
    });
    if (!resp.ok) {
      const txt = await resp.text();
      setStatus("LLM error: " + resp.status);
      structuredEl.textContent = "Ошибка: " + txt;
      return;
    }
    const j = await resp.json();
    structuredEl.textContent = JSON.stringify(j.structured || j, null, 2);
    setStatus("Готово");
  } catch (e) {
    console.error(e);
    setStatus("Ошибка LLM запросa");
    structuredEl.textContent = "Ошибка: " + e.message;
  }
}


async function copyStructured() {
  const text = structuredEl.textContent;
  if (!text) return;
  try {
    await navigator.clipboard.writeText(text);
    setStatus("Скопировано в буфер обмена");
  } catch (e) {
    console.error("Copy failed", e);
    alert("Не удалось скопировать: " + e);
  }
}


window.addEventListener("beforeunload", () => {
  if (ws && ws.readyState === WebSocket.OPEN) {
    try { ws.send(JSON.stringify({type:'close'})); } catch(e) {}
    ws.close();
  }
});
  </script>
</body>
</html>
